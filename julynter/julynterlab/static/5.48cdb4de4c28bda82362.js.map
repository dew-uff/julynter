{"version":3,"sources":["webpack:///./node_modules/codemirror/keymap/vim.js"],"names":["mod","CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","length","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","cm","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","detachVimMap","next","this","keyMap","rmClass","getWrapperElement","getOption","document","body","style","caretColor","disableFatCursorMark","attach","attachVimMap","prev","addClass","enableFatCursorMark","updateFatCursorMark","fatCursorMarks","clearFatCursorMark","ranges","listSelections","result","i","range","empty","anchor","ch","getLine","line","push","markText","className","widget","createElement","textContent","setBookmark","marks","clear","defineOption","val","Init","test","cmKey","key","undefined","vimKey","cmKeyToVimKey","cmd","findKey","modifiers","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","options","defaultValue","aliases","callback","Error","value","cfg","option","scope","local","createCircularJumpList","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","markPos","find","cursorEqual","move","offset","mark","inc","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","prototype","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","bottom","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","increment","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","substr","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","slice","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","clearTimeout","setTimeout","selections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","operation","curOp","isVimOp","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","n","getRepeat","repeat","parseInt","reason","Register","text","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","historyBuffer","iterator","initialPrefix","nextMatch","up","dir","element","pushInput","splice","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","ignoreCase","smartCase","updateSearchQuery","showConfirm","onPromptClose","scrollTo","left","top","logSearchQuery","onPromptKeyUp","close","keyName","target","selectionEnd","selectionStart","Math","min","parsedQuery","scrollIntoView","findNext","clearSearchHighlight","onPromptKeyDown","e_stop","focus","shift","showPrompt","onClose","desc","searchPromptDesc","onKeyUp","onKeyDown","word","expandWordUnderCursor","isKeyword","end","escapeRegex","exArgs","selectValueOnOpen","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","keepHPos","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","getTokenTypeAt","re","matched","findMatchingBracket","bracketRegex","to","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","selfPaired","'","selectCompanionObject","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","getRange","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","getSelection","replacement","replaceSelections","includeLineBreak","indent","startLine","endLine","indentLine","indentAuto","_args","execCommand","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","from","repeatLastEdit","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","setSelection","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","token","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","ln","curr","last_valid","skip_empty_lines","reverse","curr_index","bracketRegexp","openSym","curChar","scanForBracket","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","dialog","template","shortText","prompt","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","RegExp","regexPart","forceIgnoreCase","flagsPart","regexp","openNotification","duration","alert","makePrompt","raw","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","skipToEnd","backUp","highlightTimeout","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","history","doc","done","event","lastModTime","changeHistory","lastEditPos","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","compareFn","a","b","anum","bnum","comparePatternFn","textOld","global","matchedLines","content","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","detach","insertModeChangeRegister","lastChange","logInsertModeChange","extra","fallthrough","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding"],"mappings":"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","file":"5.48cdb4de4c28bda82362.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    function updateFatCursorMark(cm) {\n      if (!cm.state.fatCursorMarks) return;\n      clearFatCursorMark(cm);\n      var ranges = cm.listSelections(), result = []\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i]\n        if (range.empty()) {\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),\n                                    {className: \"cm-fat-cursor-mark\"}))\n          } else {\n            var widget = document.createElement(\"span\")\n            widget.textContent = \"\\u00a0\"\n            widget.className = \"cm-fat-cursor-mark\"\n            result.push(cm.setBookmark(range.anchor, {widget: widget}))\n          }\n        }\n      }\n      cm.state.fatCursorMarks = result;\n    }\n\n    function clearFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = [];\n      updateFatCursorMark(cm)\n      cm.on(\"cursorActivity\", updateFatCursorMark)\n    }\n\n    function disableFatCursorMark(cm) {\n      clearFatCursorMark(cm);\n      cm.off(\"cursorActivity\", updateFatCursorMark);\n      // explicitly set fatCursorMarks to null because event listener above\n      // can be invoke after removing it, if off is called from operation\n      cm.state.fatCursorMarks = null;\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim, keepHPos) {\n        var cur = head;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        if (!keepHPos) {\n          vim.lastHPos = Infinity;\n          vim.lastHSPos = cm.charCoords(end,'div').left;\n        }\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      } else if (markName == '.') {\n        if (cm.doc.history.lastModTime == 0) {\n          return  // If no changes, bail out; don't bother to copy or reverse history array.\n        } else {\n          var changeHistory = cm.doc.history.done.filter(function(el){ if (el.changes !== undefined) { return el } });\n          changeHistory.reverse();\n          var lastEditPos = changeHistory[0].changes[0].to;\n        }\n        return lastEditPos;\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n"],"sourceRoot":""}